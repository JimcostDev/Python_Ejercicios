# Python_Ejercicios

Este repositorio contiene ejercicios de Python, principalmente enfocados en problemas de lógica.

## Lista de ejercicios:

- [algoritmos de ordenamiento](https://github.com/JimcostDev/Python_Ejercicios/tree/master/ejercicios/algoritmos_ordenamiento): Este programa en Python te permite probar diferentes algoritmos de ordenamiento utilizando distintos conjuntos de datos como entrada. Su objetivo es comparar la eficacia de cada algoritmo y determinar cuál es más eficiente para diferentes casos.

- [chatgpt desde python](https://github.com/JimcostDev/Python_Ejercicios/tree/master/ejercicios/chatgpt_desde_python): Este código utiliza la librería OpenAI para generar respuestas a partir de preguntas introducidas por el usuario.
  
- [traductor](https://github.com/JimcostDev/Python_Ejercicios/tree/master/ejercicios/traductor): Este código utiliza la librería 'deep_translator' en Python para realizar traducciones. Utilizamos Google Translator para traducir texto y también una lista de elementos.

- [Adivina el número](https://github.com/JimcostDev/Python_Ejercicios/blob/master/ejercicios/adivina_numero.py): Este código implementa un juego simple donde tienes tres intentos para adivinar un número aleatorio entre 1 y 10. Utiliza un bucle while para gestionar los intentos del jugador y proporciona retroalimentación sobre si adivinaste o no dentro de los tres intentos permitidos.

- [Sistema de ecuaciones lineales](https://github.com/JimcostDev/Python_Ejercicios/blob/master/ejercicios/algebra_lineal.py): Este código utiliza la biblioteca NumPy en Python para resolver un sistema de ecuaciones lineales representado por una matriz A y un vector b. Calcula el determinante de la matriz A y, si no es singular, resuelve el sistema utilizando `np.linalg.solve`. Luego, c

- [Planificación de procesos - fifo](https://github.com/JimcostDev/Python_Ejercicios/blob/master/ejercicios/algoritmo_planificacion_fifo.py): Este código simula la planificación de procesos de CPU. Solicita al usuario el número de procesos, sus tiempos de llegada y ráfagas de CPU, luego los ordena según su tiempo de llegada. Calcula el tiempo de respuesta y el tiempo de espera promedio para estos procesos. Utiliza un enfoque simple de planificación de procesos para determinar estos valores.

-  [Planificación de procesos por prioridad](https://github.com/JimcostDev/Python_Ejercicios/blob/master/ejercicios/algoritmo_planificacion_x_prioridades.py): Este código simula la planificación de procesos de CPU basándose en la prioridad asignada a cada proceso. Solicita al usuario el número de procesos, sus prioridades y sus ráfagas de CPU. Luego, ordena los procesos según su prioridad y calcula el tiempo de respuesta y el tiempo de espera promedio para estos procesos utilizando esta métrica de prioridad.

- [Determinador de año bisiesto](https://github.com/JimcostDev/Python_Ejercicios/blob/master/ejercicios/anio_comun_bisiesto.py): Este código verifica si un año introducido es bisiesto o común según las reglas del calendario gregoriano. Comprueba si el año cumple con las condiciones de divisibilidad necesarias para ser considerado un año bisiesto o común. Además, emite un mensaje de advertencia si el año está fuera del período del calendario gregoriano (posterior a 1582).

- [Conversión Decimal-Fraccional](https://github.com/JimcostDev/Python_Ejercicios/blob/master/ejercicios/bin.py): Este código toma un número decimal, lo descompone en su parte entera y fraccional, convierte la parte fraccional a binario paso a paso y muestra el proceso detallado. Luego, lo imprime en formato binario. Además, presenta las partes dobles del proceso de conversión, desde la parte fraccional hasta el binario, mostrando cada valor intermedio en una lista y generando un diccionario con sus respectivos valores y claves. Esta función incluye la opción de convertir números binarios a decimales, 



## Cómo Contribuir

¡Gracias por tu interés en contribuir! Si quieres agregar más ejercicios:
1. Haz un fork de este repositorio.
2. Crea una rama con un nombre descriptivo (`git checkout -b tu-nueva-rama`).
3. Agrega tus ejercicios.
4. Haz un pull request.

## Ejemplo de Ejercicio Resuelto

```python
# Ejemplo de código resolviendo un ejercicio específico
def mi_funcion(argumentos):
    # Código de la solución
    pass
